### $Id: matrixdef,v 1.35 2008-08-28 17:36:16 lpoulson Exp $

Section language "Language"

Text language "Language name" "Name of your language: " "<br>" 50
Text iso-code "ISO code" "(optional) <a href=\"http://www.sil.org/iso639-3/codes.asp\">ISO code</a> for your language: " "" 6


Section word-order "Word Order"

Radio word-order "Basic word order" "Please indicate which pattern best describes the basic word order of your language in matrix (main) clauses:<br>" ""
. sov "Subject, Object, Verb" "" "SOV<br>"
. svo "Subject, Verb, Object" "" "SVO<br>"
. vso "Verb, Subject, Object" "" "VSO<br>"
. osv "Object, Subject, Verb" "" "OSV<br>"
. ovs "Object, Verb, Subject" "" "OVS<br>"
. vos "Verb, Subject, Object" "" "VOS<br>"
. v-final "Verb-final" "" "V-final<br>"
. v-initial "Verb-initial" "" "V-initial<br>"
. free "Free word order" "" "free (pragmatically determined word order)"

Label "<p>Note: Modules for V2 order (auxiliary second, all else free or finite verb second, non-finite verb clause-finally) and differing word order between matrix and subordinate clauses are currently under development.</p>"

Separator

Radio has-dets "Has determiners" "Does your language have determiners (as independent words)?" ""
. yes "Yes" "" "yes"
. no "No" "" "no<br>"

Radio noun-det-order "Order of determiners and nouns" "If so, what is the order of determiners with respect to nouns?" ""
. noun-det "Noun-Det" "" "Noun-Det"
. det-noun "Det-Noun" "" "Det-Noun<br><br>"

Radio has-aux "Has auxiliaries" "Does your language have auxiliary verbs?" ""
. yes "Yes" "" "yes"
. no "No" "" "no<br>"

Radio aux-comp-order "Order of auxiliary and complement" "If so, an auxiliary verb appears " ""
. before "Before" "" "before "
. after "After" "" "after its complement."


Section number "Number"

Label "<p><span style=\"font-variant:small-caps\">Number</span> is a grammatical category that distinguishes between different numbers of real-world entities.  For example, many languages distinguish a <span style=\"font-variant:small-caps\">singular</span> number from a <span style=\"font-variant:small-caps\">plural</span>, the former begin associated with one entity and the latter with more than one.  Other languages distinguish still more number values, including a <span style=\"font-variant:small-caps\">dual</span> (two entities) and a <span style=\"font-variant:small-caps\">paucal</span> (a few entities).  It is important to distinguish between number, described here, and numerals, which cannot currently be described in this questionnaire.  The answers you provide on this page will determine the values available on the lexicon page for the <tt>number</tt> feature (or the <tt>pernum</tt> feature, about which see the Person section of the questionnaire for more details).</p>"

Label "<p>Please add all the values of number that your language's grammar distinguishes.  If your language does not have number as a grammatical category, leave this section blank.</p>"

Label "<p><span style=\"color:red\">NOTE: This section of the questionnaire is currently under development and represents an over-simplified view of grammatical number.  In particular, note that the <b>first</b> value of number that you provide below will be treated as the singular, while the others will be treated as non-singular.</span></p>"

BeginIter number{i} "a Number"

  Text name "Number {i} name" "Name: " "" 20

EndIter number


Section person "Person"

Label "<p><span style=\"font-variant:small-caps\">Person</span> is a grammatical category that distinguishes between different discourse participants.  Natural languages generally distinguish up to three discourse participants: the speaker (the <span style=\"font-variant:small-caps\">first person</span>), the person spoken to (the <span style=\"font-variant:small-caps\">second person</span>), and anyone else (the <span style=\"font-variant:small-caps\">third person</span>).  The answers you provide on this page will determine what values are available later in the questionnaire for the <tt>person</tt> feature (or the <tt>pernum</tt> feature; see below).</p>"

Label "<p><span style=\"color:red\">NOTE: As with the Number section, this section of the questionnaire is currently under development and produces an over-simplified hierarchy for the <tt>person</tt> feature.</span></p>"

Radio person "Person" "<p>Which values of person are distinguished in your language?<br>" ""
. none "None" "" "none<br>"
. 1-2-3 "First, second, and third" "" "First, second, and third<br>"
. 1-non-1 "First and non-first" "" "First and non-first<br>"
. 2-non-2 "Second and non-second" "" "Second and non-second<br>"
. 3-non-3 "Third and non-third" "" "Third and non-third</p>"

Label "<p>Some languages make finer distinctions in the first person when more than one discourse participant is referred to.  The following notation, adapted from Cysouw (2000), is used here: 1+2 refers to just the speaker and the person(s) spoken to; 1+3 refers to just the speaker and some third person(s); 1+2+3 refers to the speaker, the person(s) spoken to, and some third person(s).  (Note that if your language makes a finer distinction in the first person non-singular, your grammar will have a synthetic <tt>pernum</tt> feature rather than separate <tt>person</tt> and <tt>number</tt> features.)</p>"

Radio first-person "First person" "<p>What sub-values does your language distinguish in the first person?<br>" ""
. none "None" "" " none<br>"
. incl-excl "Inclusive/exclusive" "" " (1+2 and 1+2+3) &nbsp; vs. &nbsp; 1+3 (inclusive/exclusive)<br>"
. min-incl "Minimal inclusive" "" " 1+2 &nbsp; vs. &nbsp; (1+3 and 1+2+3) (minimal inclusive)<br>"
. aug-incl "Augmented inclusive" "" " (1+2 and 1+3) &nbsp; vs. &nbsp; 1+2+3 (augmented inclusive)<br>"
. min-aug "Minimal/augmented" "" " 1+2 &nbsp; vs. &nbsp; 1+3 &nbsp; vs. &nbsp; 1+2+3 (minimal/augmented)<br>"


Section gender "Gender"

Label "<p>Hockett (1958) defines grammatical <span style=\"font-variant:small-caps\">gender</span>s as \"classes of nouns reflected in the behavior of associated words.\"  Gender is, therefore, a phenomenon that appears in patterns of agreement.  Some languages have no genders, others divide nouns into two genders (e.g. <span style=\"font-variant:small-caps\">masculine</span> and <span style=\"font-variant:small-caps\">feminine</span>, <span style=\"font-variant:small-caps\">animate</span> and <span style=\"font-variant:small-caps\">inanimate</span>, or <span style=\"font-variant:small-caps\">rational</span> and <span style=\"font-variant:small-caps\">non-rational</span>), while still others have more.  Some languages have genders that are subtypes of other genders; for example, a language may distinguish between inanimate nouns and animate nouns, and within the animate nouns, between masculine and feminine.  Any number of genders and the relationship between them can be described by creating a type hierarchy, below.  The hierarchy you define will determine what values of the <tt>gender</tt> feature are available later in the questionnaire.</p>"

Label "<p>Please add all the values of gender that your language's grammar distinguishes.  For each you will provide at least one supertype, either one of the other types you have defined or the root <tt>gender</tt> feature, which will result in the construction of a hierarchy.  If your language does not have gender as a grammatical category, leave this section blank.</p>"

BeginIter gender{i} "a Gender"

  Text name "Gender {i} name" "Gender name: " "" 20

  BeginIter supertype{j} "a Supertype" 1

    Select name "Gender {i} supertype {j} name" "Supertype: " ""
    fillregex gender[0-9]+_name 1
    . gender "Gender" "gender"

  EndIter supertype

EndIter gender


Section other-features "Other Features"

Label "<p>If your language has other features beyond those that can be defined elsewhere in this questionnaire, you can define those features here.  For example, if your language has synthetic features (e.g. <tt>pernum</tt> instead of <tt>person</tt> and <tt>number</tt>, <tt>gendnum</tt> instead of <tt>gender</tt> and <tt>number</tt>), they can be defined below.</p>"

Label "<p>For each feature, you will define a type hierarchy, which consists of a root type you will name (e.g. <tt>pernum</tt>), and then a series of other values of the feature, each of which is the subtype of at least one of the other values, including the root.</p>"

BeginIter feature{i} "a Feature"

  Text name "Feature {i} name" "Feature name: " "<br>" 20

  Radio type "Feature {i} type" "Is this feature:<br>" ""
  . head "Head" "" " a syntactic feature (will go under HEAD)?<br>"
  . index "Index" "" " a semantic feature (will go under INDEX)?<br>"

  Label "Values in the feature hierarchy:"

  BeginIter value{j} "a Value"

   Text name "Feature {i} Value {j} name" "Value name: " "" 20

    BeginIter supertype{k} "a Supertype" 1

      Select name "Feature {i} Value {j} supertype {k} name" "Supertype: " ""
      fillregex (feature{i}_name|feature{i}_value[0-9]+_name) 1

    EndIter supertype

  EndIter value

EndIter feature


Section case "Case"

Label "<p>Blake (2001) defines <span style=\"font-variant:small-caps\">case</span> as &quot;a system of marking dependent nouns for the type of relationship they bear to their heads.&quot; For example, case commonly marks the subject or the direct object of a verb. The marking might consist of affixation or some other morpholological process that marks words, or it might be a adposition that marks whole noun phrases.</p>"
Label "<p>This questionnaire allows you to describe <span style=\"font-variant:small-caps\">core case marking</span> in your language; that is, the pattern of cases marking the mandatory arguments of transitive and intransitive verbs.  Following Dixon (1968), we refer to the grammatical relations commonly expressed by case using the following abbreviations: A refers to the agent of a transitive verb; O refers to the patient (or object) of a transitive verb; and S refers to the lone argument (or subject) of intransitive verbs.</p>"

Radio case-marking "Core case marking" "<p>What type of core case marking does your language exhibit?</p>" ""
. none "None" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>None</b><br>(Verbal argument roles are determined only by word order, by intonation, or pragmatically.)</p>"
. nom-acc "Nominative-accusative" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>Nominative-accusative</b><br>"

Text nom-acc-nom-case-name "Nominative case name" "S and A take a case named the " " (e.g. nominative, subjective)<br>" 20

Text nom-acc-acc-case-name "Accusative case name" "O takes a case named the " " (e.g. accusative, objective)<br>" 20

Radio case-marking "Core case marking" "" ""
. erg-abs "Ergative-absolutive" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>Ergative-absolutive</b><br>"

Text erg-abs-erg-case-name "Ergative case name" "A takes a case named the " " (e.g. ergative, relative, narrative)<br>" 20

Text erg-abs-abs-case-name "Absolutive case name" "S and O take a case named the " " (e.g. absolutive, nominative)<br>" 20

Radio case-marking "Core case marking" "" ""
. tripartite "Tripartite" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>Tripartite</b><br>"

Text tripartite-s-case-name "S case name" "S takes a case named the " " (e.g. nominative, subjective)<br>" 20

Text tripartite-a-case-name "A case name" "A takes a case named the " " (e.g. ergative, agentive)<br>" 20

Text tripartite-o-case-name "O case name" "O takes a case named the " " (e.g. absolutive, patientive)<br>" 20

Radio case-marking "Core case marking" "" ""
. split-s "Split-S" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>Split-S</b><br>"

Label "(The S argument of some intransitive verbs is marked by the same case as the agent of transitives, while for other verbs the S argument is marked by the same case as the patient.)<br>"

Text split-s-a-case-name "A case name" "A takes a case named the " " (e.g. ergative, agentive)<br>" 20

Text split-s-o-case-name "O case name" "O takes a case named the " " (e.g. absolutive, patientive)<br>" 20

Radio case-marking "Core case marking" "" ""
. fluid-s "Fluid-S" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>Fluid-S</b><br>"

Label "(The S argument of any intransitive verb can be marked either by the same case as the transitive agent or patient, depending on pragmatic factors, e.g. whether the S is perceived as being in control of the action.)<br>"

Text fluid-s-a-case-name "A case name" "A takes a case named the " " (e.g. ergative, agentive)<br>" 20

Text fluid-s-o-case-name "O case name" "O takes a case named the " " (e.g. absolutive, patientive)<br>" 20

Radio case-marking "Core case marking" "" ""
. split-n "Split N" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>Split conditioned on features of the noun phrase arguments</b><br>"

Label "(Some classes of noun phrases (e.g. pronouns) show a nominative-accusative pattern, while others (e.g. common nouns) show an ergative-absolutive pattern.  You will have an opportunity to define these classes on the Lexicon page.)<br>"

Text split-n-nom-case-name "Nominative case name" "S and A take a case named the " " (e.g. nominative, subjective)<br>" 20

Text split-n-acc-case-name "Accusative case name" "O takes a case named the " " (e.g. accusative, objective)<br>" 20

Text split-n-erg-case-name "Ergative case name" "A takes a case named the " " (e.g. ergative, relative, narrative)<br>" 20

Text split-n-abs-case-name "Absolutive case name" "S and O take a case named the " " (e.g. absolutive, nominative)<br>" 20

Radio case-marking "Core case marking" "" ""
. split-v "Split V" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>Split conditioned on features of the verb</b><br>"

Label "(Depending on some feature of the verb (e.g. tense or aspect), the core arguments are sometimes marked in a nominative-accusative pattern and other times in an ergative-absolutive pattern.  You will have an opportunity to define these features on the Lexicon page.)<br>"

Text split-v-nom-case-name "Nominative case name" "S and A take a case named the " " (e.g. nominative, subjective)<br>" 20

Text split-v-acc-case-name "Accusative case name" "O takes a case named the " " (e.g. accusative, objective)<br>" 20

Text split-v-erg-case-name "Ergative case name" "A takes a case named the " " (e.g. ergative, relative, narrative)<br>" 20

Text split-v-abs-case-name "Absolutive case name" "S and O take a case named the " " (e.g. absolutive, nominative)<br>" 20

Radio case-marking "Core case marking" "" ""
. focus "Focus" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>Focus-case</b><br>"

Label "(A number of Austronesian languages, including several Philippine languages, have a system where A and O are marked by cases.  An additional case, sometimes called the <span style=\"font-variant:small-caps\">focus</span>, is mandatory in every clause and has its grammatical role assigned by the morphology of the verb.  You will have an opportunity to define this morphology on the Lexicon page.)<br>"

Text focus-focus-case-name "Focus case name" "The focus case is named the " "<br>" 20

Text focus-a-case-name "A case name" "A takes a case named the " " (e.g. ergative, relative, narrative)<br>" 20

Text focus-o-case-name "O case name" "O takes a case named the " " (e.g. accusative, objective)<br>" 20

Label "<p><b>Additional Cases</b></p><p>If your language has any additional cases not covered above that occur in simple intransitive or transitive clauses (e.g. if you language has verbs whose O is marked by the dative), define those cases here:</p>"

BeginIter case{i} "a Case"

  Text name "Case {i} name" "Name: " "" 20

EndIter case


Section direct-inverse "Direct-inverse"

Label "<p>In some languages, the pattern of marking of verbal arguments (or verbs themselves) is sensitive to a <span style=\"font-variant:small-caps\">scale</span> that ranks argument noun phrases according to how natural they are in the role of agent; for example, a language might rank animate NPs as more natural agents than inanimate NPs.  In such languages, transitive sentences in which the agent outranks the patient are marked differently from those in which the patient outranks the agent.  Such sentences are said to differ in <span style=\"font-variant:small-caps\">direction</span>.  Sentences where the agent outranks the patient are called <span style=\"font-variant:small-caps\">direct</span>, while sentences where the patient outranks the agent are called <span style=\"font-variant:small-caps\">inverse</span>.  The difference between direct and inverse sentences may be marked by a different verb form, by different cases on the argument NPs, or both.  Creating a direct-inverse scale here will make available, on the Lexicon page, argument structures for verbs that are sensitive to the scale, and also the <tt>direction</tt> feature for use in verbal inflection.</p>"

Label "<p>If your language shows the direct-inverse pattern, please describe the features that define the scale below.  The scale entries should be entered in order from the highest (most agent-like) to the lowest (most patient-like).</p>"

BeginIter scale{i} "a Scale Entry"

  Label "<b>Scale entry {i}</b><br>Features:"

  BeginIter feat{j} "a Feature" 1

    Select name "Scale entry {i} feature {j} name" "Name: " " "
    fillnames

    Select value "Scale entry {i} feature {j} value" "Value: " ""
    fillvalues scale{i}_feat{j}_name

  EndIter feat

EndIter scale

Select scale-equal "Direction when equal" "When the agent and patient have the same scale value, the main verb is " "<br>(The other form may be something like a reflexive.  If you select \"some other form\", the resulting grammar will not parse sentences where the agent and patient are equally ranked.  You will need to edit the starter grammar manually to add the other form.)"
. direct "Direct" "direct"
. other "Some other form" "some other form"

Section tense-aspect "Tense and Aspect"

Label "<h3>Tense</h3>" 

Label "You may define a tense hierarchy in one of two ways:"
Label "<ul><li>Select among the following common hierarchy elements and add subtypes as needed, or <li>Build your own hierarchy.</ul>"

Radio tense-definition "Tense hierarchy definition style" "" ""
. choose "Choose" "" "<b>Select among common hierarchy elements</b><br>"

Label "<br>Which of the following are tense hierarchy elements in your language?<br><br>" ""

Check past "Past" "" "<b>past</b><br>"
  BeginIter past-subtype{i} "a subtype"
    Text name "Past subtype {i} name" "Subtype: " "" 20
  EndIter past-subtype

Check present "Present" "" "<b>present</b><br>"
  BeginIter present-subtype{i} "a subtype"
    Text name "Present subtype {i} name" "Subtype: " "" 20
  EndIter present-subtype

Check future "Future" "" "<b>future</b><br>"
  BeginIter future-subtype{i} "a subtype"
    Text name "Future subtype {i} name" "Subtype: " "" 20
  EndIter future-subtype

Check non-past "Non-Past" "" "<b>non-past</b> &nbsp;&nbsp;&nbsp;&nbsp;(If present and/or future are also selected they are assumed to be subtypes of non-past.)<br>"
  BeginIter non-past-subtype{i} "a subtype"
    Text name "Non-Past subtype {i} name" "Subtype: " "" 20
  EndIter non-past-subtype

Check non-future "Non-Future" "" "<b>non-future</b> &nbsp;&nbsp;&nbsp;&nbsp;(If present and/or past are also selected they are assumed to be subtypes of non-future.)<br>"
  BeginIter non-future-subtype{i} "a subtype"
    Text name "Non-Future subtype {i} name" "Subtype: " "" 20
  EndIter non-future-subtype

Radio tense-definition "Tense hierarchy definition style" "" ""
. build "Build" "" "<b>Build your own tense hierarchy</b><br>"

Label "<br>Build your hierarchy from the top down starting with subtypes of the supertype: tense.</p>"
Label "Example:<br>"
Label "subtype name: nonpast<br>"
Label "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;supertype: tense<br><br>"

BeginIter tense{i} "a tense type"

  Text name "tense {i} name" "Subtype name: " "" 20

  BeginIter supertype{j} "a Supertype" 1

    Select name "Tense {i} supertype {j} name" "Supertype: " ""
    fillregex tense[0-9]+_name 1
    . tense "Tense" "tense"

  EndIter supertype

EndIter tense

Label "<br><h3>Aspect</h3>"

Label "<p>This implementation assumes no universally accepted hierarchy or terminology of grammatical aspect. You may build an appropriate hierarchy of grammatical aspect values below.</p>"

Label "<h4>Build your own aspect hierarchy</h4>"
Label "Build your hierarchy from the top down starting with subtypes of the supertype: aspect.</p>"
Label "Example:<br>"
Label "subtype name: imperfective<br>"
Label "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;supertype: aspect<br><br>"

BeginIter aspect{i} "an aspect type"

  Text name "aspect {i} name" "Subtype name: " "" 20
  BeginIter supertype{j} "a Supertype" 1

    Select name "Aspect {i} supertype {j} name" "Supertype: " ""
    fillregex aspect[0-9]+_name 1
    . aspect "Aspect" "aspect"

  EndIter supertype

EndIter aspect


Section sentential-negation "Sentential Negation"

Label "<p>Please indicate which strategy or strategies your language uses for sentential negation (as distinct from constituent negation). (You may leave this section blank, in which case your grammar will not include any information about negation.)</p>"

Check infl-neg "Negation by inflection" "<p>" "Verbal inflection:<br>"

Radio neg-infl-type "Negative inflection type" "On: " ""
. aux "Auxiliaries only" "" "auxiliaries only "
. main "Main verbs only" "" "main verbs only "
. aux-main "Main or auxiliary verbs" "" "any finite verb (main or auxiliary)<br>"

Radio neg-aff "Negative affix type" "Affix type: " ""
. prefix "Prefix" "" "prefix "
. suffix "Suffix" "" "suffix<br>"

Text neg-aff-orth "Negative affix spelling" "Affix Spelling: " "</p>" 20

Check adv-neg "Adverbial negation" "<p>" "An adverb:<br>"

Radio neg-adv "Negative adverb" "" ""
. ind-adv "Independent" "" "...which is an independent modifier of "

Radio neg-mod "Negative adverb modifies" "" ""
. s "S" "" "S "
. vp "VP" "" "VP "
. v "V" "" "V "

Radio neg-order "Negative adverb order" "and appears " ""
. before "Before" "" "before "
. after "After" "" "after "
. either "Either" "" "on either side of the category it modifies.<br>"

Radio neg-adv "Negative adverb" "" ""
. sel-adv "Selected complement negative adverb" "" "...which is a selected complement of "

Radio neg-sel-adv "Negative adverb selects" "" ""
. main "Main verbs" "" "main verbs "
. aux "Auxiliary verbs" "" "auxiliaries "
. main-aux "Main or auxiliary verbs" "" "any finite verb<br>"

Text neg-adv-orth "Negative adverb spelling" "...and which is spelled: " "</p>" 20

Label "<p>Notes: The following options are not yet implemented: Negative inflection of non-finite verbs, special negative auxiliaries.</p>"

Radio multi-neg "Negative inflection and adverb" "<p>If you have selected both inflectional and adverbial negation, please indicate which of the following best describes your language:<br>" "</p>"
. comp "Complementary distribution" "" "Inflectional and adverbial negation are used in complementary distribution.<br>"
. both-opt "Both optional" "" "Inflectional and adverbial negation can appear independently or together.<br>"
. both-obl "Both obligatory" "" "Both inflection and the adverb are required to express sentential negation.<br>"
. adv-obl "Adverb obligatory" "" "The adverb is obligatory, but inflection may appear in addition.<br>"
. infl-obl "Inflection obligatory" "" "The inflection is obligatory, but the adverb may appear in addition."

Label "<p>Note: We assume that when negation is expressed via both inflection and an adverb at the same time, the adverb is treated as a selected complement.</p>"


Section coordination "Coordination"

Label "<p>Languages can have have multiple ways of marking coordination that can differ among the various parts of speech. The Matrix supports both lexical and morphological marking of coordination in several patterns. These patterns include:</p>"

Label "<blockquote><p><span style=\"font-variant:small-caps\">Monosyndeton</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;A B and C&quot; (one coordinand marked; also permits &quot;A and B and C&quot;)<br><span style=\"font-variant:small-caps\">Polysyndeton</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;A and B and C&quot; (for N coordinands, N-1 marked)<br><span style=\"font-variant:small-caps\">N-Polysyndeton</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;and A and B and C&quot; (all coordinands marked)<br><span style=\"font-variant:small-caps\">Asyndeton</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;A B C&quot; (no marking; also called &quot;juxtaposition&quot;)</blockquote></p>"

Label "<p>You may define up to two coordination strategies below.  You may also leave this section blank, in which case the starter grammar produced will not have coordination.</p>"

Check cs1 "Coordination strategy 1" "" "Coordination Strategy 1:<br>&nbsp;&nbsp;&nbsp;&nbsp;in which"

Check cs1_n "CS1 coordinates Ns" "" "nouns "
Check cs1_np "CS1 coordinates NPs" "" "NPs "
Check cs1_vp "CS1 coordinates VPs" "" "VPs "
Check cs1_s "CS1 coordinates Ss" "" "sentences<br>"

Radio cs1_pat "CS1 pattern" "&nbsp;&nbsp;&nbsp;&nbsp;are marked in a " ""
. mono "Monosyndeton" "" "monosyndeton "
. poly "Polysyndeton" "" "polysyndeton "
. omni "N-polysyndeton" "" "N-polysyndeton "
. a "Asyndeton" "" "asyndeton &nbsp; pattern<br>"

Radio cs1_mark "CS1 mark" "&nbsp;&nbsp;&nbsp;&nbsp;by a " ""
. word "Word" "" "word "
. affix "Affix" "" "affix "

Text cs1_orth "CS1 spelling" "spelled " "" 10

Radio cs1_order "CS1 order" "that comes " ""
. before "Before" "" "before "
. after "After" "" "after the coordinand<br><br>"

Check cs2 "Coordination strategy 2" "" "Coordination Strategy 2:<br>&nbsp;&nbsp;&nbsp;&nbsp;in which"

Check cs2_n "CS2 coordinates Ns" "" "nouns "
Check cs2_np "CS2 coordinates NPs" "" "NPs "
Check cs2_vp "CS2 coordinates VPs" "" "VPs "
Check cs2_s "CS2 coordinates Ss" "" "sentences<br>"

Radio cs2_pat "CS2 pattern" "&nbsp;&nbsp;&nbsp;&nbsp;are marked in a " ""
. mono "Monosyndeton" "" "monosyndeton "
. poly "Polysyndeton" "" "polysyndeton "
. omni "N-polysyndeton" "" "N-polysyndeton "
. a "Asyndeton" "" "asyndeton &nbsp; pattern<br>"

Radio cs2_mark "CS2 mark" "&nbsp;&nbsp;&nbsp;&nbsp;by a " ""
. word "Word" "" "word "
. affix "Affix" "" "affix "

Text cs2_orth "CS2 spelling" "spelled " "" 10

Radio cs2_order "CS2 order" "that comes " ""
. before "Before" "" "before "
. after "After" "" "after the coordinand "


Section matrix-yes-no "Matrix Yes/No Questions"

Label "<p>Please indicate which strategy your language uses to form matrix yes-no questions.  You may leave this section blank, in which case your grammar will not include a question-forming strategy.</p>"

Check q-part "Yes/No question particle" "" "A separate question particle: "

Radio q-part-order "Question particle order" "" ""
. before "Before" "" "sentence initial "
. after "After" "" "sentence final<br>"

Text q-part-orth "Question particle spelling" "&nbsp;&nbsp;&nbsp;&nbsp;Spelling of question particle: " "<br>" 40

Check q-infl "Inflection" "" "Verbal inflection:<br>"

Radio q-infl-type "Inflection type" "&nbsp;&nbsp;&nbsp;&nbsp;On: " ""
. aux "Auxiliaries only" "" "auxiliaries only "
. main "Main verbs only" "" "main verbs only "
. aux-main "Main or auxiliary verbs" "" "any finite verb (main or auxiliary)<br>"

Radio ques-aff "Affix type" "&nbsp;&nbsp;&nbsp;&nbsp;Affix type: " ""
. prefix "Prefix" "" "prefix "
. suffix "Suffix" "" "suffix<br>"

Text ques-aff-orth "Affix spelling" "&nbsp;&nbsp;&nbsp;&nbsp;Affix Spelling: " "<br>" 10

Check q-inv "Subject-verb inversion" "" "Subject-verb inversion: "

Radio q-inv-verb "Inverted verb in questions" "" ""
. main "Main" "" "main verbs only "
. aux "Auxiliary" "" "auxiliaries only "
. main-aux "Main and auxiliary" "" "any verb<br>"


Section lexicon "Lexicon"

Label "<p>On this page you will define lexical types and lexical items within those types.  For most lexical items you must provide both the spelling of the stem and a predicate (e.g. _cat_n_rel, _sleep_v_rel).</p>"

Label "<p>In addition to lexical types, you can define inflectional morphology for nouns, verbs, and determiners.  To do so, first define one or more inflectional <span style=\"font-variant:small-caps\">slots</span>, which determine the order in which morphemes appear, then define one or more <span style=\"font-variant:small-caps\">morphemes</span> that can appear in each slot, along with the <span style=\"font-variant:small-caps\">features</span> specified by each morpheme.  To determine the order of slots, you must define one or more <span style=\"font-variant:small-caps\">inputs</span> for each.  For morphemes that attach directly to stems, the input will be a lexical type; for morphemes that attach to already-inflected stems, the input will be another slot.</p>"

Separator

Label "<h3>Noun Types</h3>"

BeginIter noun{i} "a Noun Type" 1

  Label "<b>Noun type {i}</b>:"

  Label "<div style=\"padding-left: 16px\">"

  Text name "Noun {i} name" "Type name: " "<br>" 20

  Label "Stems:"

  BeginIter stem{j} "a Stem" 1

    Text orth "Noun {i} stem {j} spelling" "Spelling: " "" 30

    Text pred "Noun {i} stem {j} predicate" " Predicate: " "" 30

  EndIter stem

  Label "Features:"

  BeginIter feat{j} "a Feature"

    Select name "Noun {i} feature {j} name" "Name: " " "
    fillnames

    Select value "Noun {i} feature {j} value" "Value: " ""
    fillvalues noun{i}_feat{j}_name

  EndIter feat

  Radio det "Noun {i} determiner" "<p>For nouns of this type, a determiner is " "</p>"
  . obl "Obligatory" "" "obligatory "
  . opt "Optional" "" "optional "
  . imp "Impossible" "" "impossible "

  Label "</div>"

EndIter noun

Separator

Label "<h3>Noun Inflection</h3>"

BeginIter noun-slot{i} "a Slot"

  Text name "Noun slot {i} name" "<b>Noun slot {i}</b>:<br>Slot name: " " " 20

  Check opt "Noun slot {i} optional" ", which is " " optional"

  Select order "Noun slot {i} order" " and appears " " the following inputs:<br>"
  . after "After" "after"
  . before "Before" "before"

  BeginIter input{j} "an Input" 1

    Select type "Noun slot {i} input {j} type" "Input: " ""
    fillregex (noun|verb|det)(-slot)?[0-9]+_name
    . noun "Any noun" "any noun"
    . verb "Any verb" "any verb"
    . iverb "Any intransitive verb" "any intransitive verb"
    . tverb "Any transitive verb" "any transitive verb"

  EndIter input

  BeginIter forces{j} "a Forced Slot"

    Select type "Noun slot {i} forces {j} type" "Forced slot: " ""
    fillregex (noun|verb|det)(-slot)?[0-9]+_name

  EndIter forces

  BeginIter req{j} "a Required Slot"

    Select type "Noun slot {i} req {j} type" "If <b>Noun slot {i}</b> appears, " " must also appear."
    fillregex (noun|verb|det)(-slot)?[0-9]+_name

  EndIter req

  BeginIter disreq{j} "a Forbidden Slot"

    Select type "Noun slot {i} req {j} type" "If <b>Noun slot {i}</b> appears, " " must <b>not</b> appear."
    fillregex (noun|verb|det)(-slot)?[0-9]+_name

  EndIter disreq

  Label "<p>Morpheme(s) that appear in this slot:</p>"

  BeginIter morph{j} "a Morpheme"

    Text name "Noun slot {i} morpheme {j} name" "Morpheme name: " ", " 20

    Text orth "Noun slot {i} morpheme {j} spelling" "spelling: " ", with the following features:<br>" 20

    BeginIter feat{k} "a Feature"

      Select name "Noun slot {i} morpheme {j} feature {k} name" "Name: " " "
      fillnames

      Select value "Noun slot {i} morpheme {j} feature {k} value" "Value: " ""
      fillvalues noun-slot{i}_morph{j}_feat{k}_name

    EndIter feat

  EndIter morph

EndIter noun-slot

Separator

Label "<h3>Verb Types</h3>"

BeginIter verb{i} "a Verb Type" 2

  Label "<b>Verb type {i}</b>:"

  Label "<div style=\"padding-left: 16px\">"

  Text name "Verb {i} name" "Type name: " "<br>" 20

  BeginIter stem{j} "a Stem" 1

    Text orth "Verb {i} stem {j} spelling" "Spelling: " "" 30

    Text pred "Verb {i} stem {j} predicate" " Predicate: " "" 30

  EndIter stem

  Label "Features:"

  BeginIter feat{j} "a Feature"

    Select name "Verb {i} feature {j} name" "Name: " " "
    fillnames

    Select value "Verb {i} feature {j} value" "Value: " ""
    fillvalues verb{i}_feat{j}_name

    Select head "Verb {i} feature {j} head" "Specified on: " ""
    . verb "The verb" "the verb"
    . subj "The subject" "the subject NP"
    . obj "The object" "the object NP"

  EndIter feat

  Select valence "Verb {i} arguments" "<p>Argument structure: " "</p>"
  fillverbpat

  Label "</div>"

EndIter verb

Separator

Label "<h3>Auxiliary Verb Types</h3>"

BeginIter aux{i} "an Aux Type" 

  Label "<b>Auxiliary type {i}</b>:"

  Label "<div style=\"padding-left: 16px\">"

  Text name "Aux {i} type name" "<b>Auxiliary type {i}</b>:<br>Name: " "<br>" 20

  Text orth "Aux {i} spelling" "Spelling: " "" 30

  Radio sem "Aux {i} semantics" "<br>This auxiliary verb contributes:<br>" ""
  . add-pred "Predicate" "" "An independent predicate (e.g. _can_v_rel)"

  Text pred "Aux{i} predicate " "&nbsp;&nbsp;&nbsp;Predicate: " "" 30

  Radio sem "Aux {i} semantics" "<br>" ""
  . no-pred "No predicate" "" "Tense/aspect information only"

  Radio comp "Aux {i} complement" "<br>This auxiliary verb takes as its complement a:<br>" ""
  . s "S" "" "saturated sentence<br>"
  . vp "VP" "" "VP, raising the subject<br>"
  . v "V" "" "V, raising all of its arguments (argument composition)"

  Radio compform "Aux {i} complement verb form" "<br>The form of the verb in this auxiliary's complement must be:<br>" ""
  . finite "finite" "" "finite<br>"
  . nonfinite "nonfinite" "" "non-finite"

  Text nonfincompform "Aux {i} non-finite complement form" "&nbsp;&nbsp;&nbsp;Non-finite form (e.g. infinitive): " "<br>" 30

  Radio subj "Aux {i} subject" "If the auxiliary takes a VP or V complement, its subject is a: " ""
  . np "Noun phrase" "" "noun phrase "
  . adp "Adpositional phrase" "" "adpositional phrase "

  Label "</div>"

EndIter aux

Separator

Label "<h3>Verb Inflection</h3>"

BeginIter verb-slot{i} "a Slot"

  Text name "Verb slot {i} name" "<b>Verb slot {i}</b>:<br>Slot name: " " " 20

  Check opt "Verb slot {i} optional" ", which is " " optional"

  Select order "Verb slot {i} order" " and appears " " the following inputs:<br>"
  . after "After" "after"
  . before "Before" "before"

  BeginIter input{j} "an Input" 1

    Select type "Verb slot {i} input {j} type" "Input: " ""
    fillregex (noun|verb|aux|det)(-slot)?[0-9]+_name
    . noun "Any noun" "any noun"
    . verb "Any verb" "any verb"
    . iverb "Any intransitive verb" "any intransitive verb"
    . tverb "Any transitive verb" "any transitive verb"
    . aux "Any auxiliary verb" "any auxiliary verb"

  EndIter input

  BeginIter forces{j} "a Forced Slot"

    Select type "Verb slot {i} forces {j} type" "Forced slot: " ""
    fillregex (noun|verb|aux|det)(-slot)?[0-9]+_name

  EndIter forces

  BeginIter req{j} "a Required Slot"

    Select type "Verb slot {i} req {j} type" "If <b>Verb slot {i}</b> appears, " " must also appear."
    fillregex (noun|verb|aux|det)(-slot)?[0-9]+_name

  EndIter req

  BeginIter disreq{j} "a Forbidden Slot"

    Select type "Verb slot {i} req {j} type" "If <b>Verb slot {i}</b> appears, " " must <b>not</b> appear."
    fillregex (noun|verb|aux|det)(-slot)?[0-9]+_name

  EndIter disreq

  Label "<p>Morpheme(s) that appear in this slot:</p>"

  BeginIter morph{j} "a Morpheme"

    Text name "Verb slot {i} morpheme {j} name" "Morpheme name: " ", " 20

    Text orth "Verb slot {i} morpheme {j} spelling" "spelling: " ", with the following features:<br>" 20

    BeginIter feat{k} "a Feature"

      Select name "Verb slot {i} morpheme {j} feature {k} name" "Name: " " "
      fillnames

      Select value "Verb slot {i} morpheme {j} feature {k} value" "Value: " ""
      fillvalues verb-slot{i}_morph{j}_feat{k}_name

      Select head "Verb slot {i} morpheme {j} feature {k} head" "Specified on: " ""
      . verb "The verb" "the verb"
      . subj "The subject" "the subject NP"
      . obj "The object" "the object NP"

    EndIter feat

  EndIter morph

EndIter verb-slot

Separator

Label "<h3>Determiners</h3>"

BeginIter det{i} "a Determiner"

  Label "<b>Determiner type {i}</b>:"

  Label "<div style=\"padding-left: 16px\">"

  Text name "Determiner {i} name" "Type name: " "<br>" 20

  BeginIter stem{j} "a Stem" 1

    Text orth "Determiner {i} spelling" "Spelling: " "" 30

    Text pred "Determiner {i} predicate" " Predicate: " "<br>" 30

  EndIter stem

  Label "Features:"

  BeginIter feat{j} "a Feature"

    Select name "Determiner {i} feature {j} name" "Name: " " "
    fillnames

    Select value "Determiner {i} feature {j} value" "Value: " ""
    fillvalues det{i}_feat{j}_name

  EndIter feat

  Label "</div>"

EndIter det

Separator

Label "<h3>Determiner Inflection</h3>"

BeginIter det-slot{i} "a Slot"

  Text name "Determiner slot {i} name" "<b>Determiner slot {i}</b>:<br>Slot name: " " " 20

  Check opt "Determiner slot {i} optional" ", which is " " optional"

  Select order "Determiner slot {i} order" " and appears " " the following inputs:<br>"
  . after "After" "after"
  . before "Before" "before"

  BeginIter input{j} "an Input" 1

    Select type "Determiner slot {i} input {j} type" "Input: " ""
    fillregex (noun|verb|det)(-slot)?[0-9]+_name
    . noun "Any noun" "any noun"
    . verb "Any verb" "any verb"
    . iverb "Any intransitive verb" "any intransitive verb"
    . tverb "Any transitive verb" "any transitive verb"

  EndIter input

  BeginIter forces{j} "a Forced Slot"

    Select type "Determiner slot {i} forces {j} type" "Forced slot: " ""
    fillregex (noun|verb|det)(-slot)?[0-9]+_name

  EndIter forces

  BeginIter req{j} "a Required Slot"

    Select type "Determiner slot {i} req {j} type" "If <b>Determiner slot {i}</b> appears, " " must also appear."
    fillregex (noun|verb|det)(-slot)?[0-9]+_name

  EndIter req

  BeginIter disreq{j} "a Forbidden Slot"

    Select type "Determiner slot {i} req {j} type" "If <b>Determiner slot {i}</b> appears, " " must <b>not</b> appear."
    fillregex (noun|verb|det)(-slot)?[0-9]+_name

  EndIter disreq

  Label "<p>Morpheme(s) that appear in this slot:</p>"

  BeginIter morph{j} "a Morpheme"

    Text name "Determiner slot {i} morpheme {j} name" "Morpheme name: " ", " 20

    Text orth "Determiner slot {i} morpheme {j} spelling" "spelling: " ", with the following features:<br>" 20

    BeginIter feat{k} "a Feature"

      Select name "Determiner slot {i} morpheme {j} feature {k} name" "Name: " " "
      fillnames

      Select value "Determiner slot {i} morpheme {j} feature {k} value" "Value: " ""
      fillvalues det-slot{i}_morph{j}_feat{k}_name

    EndIter feat

  EndIter morph

EndIter det-slot

Separator

Label "<h3>Case-marking Adpositions</h3>"

BeginIter adp{i} "an Adposition"

  Text orth "Adposition {i} spelling" "Spelling: " "" 20

  Select order "Noun slot {i} order" ", appearing " " an NP, on which it sets the following features:<br>"
  . after "After" "after"
  . before "Before" "before"

  BeginIter feat{j} "a Feature"

    Select name "Adposition {i} feature {j} name" "Name: " " "
    fillnames

    Select value "Adposition {i} feature {j} value" "Value: " ""
    fillvalues adp{i}_feat{j}_name

  EndIter feat

EndIter adp


Section test-sentences "Some Test Sentences"

Label "<p>In this section, you can provide example sentences that will as defaults in the LKB's parse dialog.  Please write sentences using <b>only</b> the vocabulary defined in the Lexicon section.</p>"

Text sentence1 "Sentence 1" "<p>Sentence 1: " "</p>" 100

Text sentence2 "Sentence 2" "<p>Sentence 2: " "</p>" 100
