### $Id: matrixdef,v 1.27 2008-07-04 01:03:33 lpoulson Exp $

Section language "Language"

Text language "Language name" "<p>e.g. Warlpiri or Hawaiian_Creole: " "</p>" 50

Section word-order "Word Order"

Radio word-order "Basic word order" "Please indicate which pattern best describes the basic word order of your language in matrix (main) clauses:<br>" ""
. sov "Subject, Object, Verb" "" "SOV<br>"
. svo "Subject, Verb, Object" "" "SVO<br>"
. vso "Verb, Subject, Object" "" "VSO<br>"
. osv "Object, Subject, Verb" "" "OSV<br>"
. ovs "Object, Verb, Subject" "" "OVS<br>"
. vos "Verb, Subject, Object" "" "VOS<br>"
. v-final "Verb-final" "" "V-final<br>"
. v-initial "Verb-initial" "" "V-initial<br>"
. free "Free word order" "" "free (pragmatically determined word order)"

Label "<p>Note: Modules for V2 order (auxiliary second, all else free or finite verb second, non-finite verb clause-finally) and differing word order between matrix and subordinate clauses are currently under development.</p>"

Radio has-dets "Has determiners" "Does your language have determiners (as independent words)?" ""
. yes "Yes" "" "yes"
. no "No" "" "no<br><br>"

Radio noun-det-order "Order of determiners and nouns" "If so, what is the order of determiners with respect to nouns?" ""
. noun-det "Noun-Det" "" "Noun-Det"
. det-noun "Det-Noun" "" "Det-Noun<br><br>"

Radio has-aux "Has auxiliaries" "Does your language have auxiliary verbs?" ""
. yes "Yes" "" "yes"
. no "No" "" "no<br><br>"

Radio aux-comp-order "Order of auxiliary and complement" "If so, an auxiliary verb appears " ""
. before "Before" "" "before "
. after "After" "" "after its complement."

Section case "Case"

Label "<p>Blake (2001) defines <span style=\"font-variant:small-caps\">case</span> as &quot;a system of marking dependent nouns for the type of relationship they bear to their heads.&quot; For example, case commonly marks the subject or the direct object of a verb. The marking might consist of affixation or some other morpholological process that marks words, or it might be a adposition that marks whole noun phrases.</p>"
Label "<p>This questionnaire allows you to describe <span style=\"font-variant:small-caps\">core case marking</span> in your language; that is, the pattern of cases marking the mandatory arguments of transitive and intransitive verbs.  Following Dixon (1968), we refer to the grammatical relations commonly expressed by case using the following abbreviations: A refers to the agent of a transitive verb; O refers to the patient (or object) of a transitive verb; and S refers to the lone argument (or subject) of intransitive verbs.</p>"

Radio case-marking "Core case marking" "<p>What type of core case marking does your language exhibit?</p>" ""
. none "None" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>None</b><br>(Verbal argument roles are determined only by word order, by intonation, or pragmatically.)</p>"
. nom-acc "Nominative-accusative" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>Nominative-accusative</b><br>"

Text nom-acc-nom-case-name "Nominative case name" "S and A take a case named the " " (e.g. nominative, subjective)<br>" 20

Text nom-acc-acc-case-name "Accusative case name" "O takes a case named the " " (e.g. accusative, objective)<br>" 20

Radio case-marking "Core case marking" "" ""
. erg-abs "Ergative-absolutive" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>Ergative-absolutive</b><br>"

Text erg-abs-erg-case-name "Ergative case name" "A takes a case named the " " (e.g. ergative, relative, narrative)<br>" 20

Text erg-abs-abs-case-name "Absolutive case name" "S and O take a case named the " " (e.g. absolutive, nominative)<br>" 20

Radio case-marking "Core case marking" "" ""
. tripartite "Tripartite" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>Tripartite</b><br>"

Text tripartite-s-case-name "S case name" "S takes a case named the " " (e.g. nominative, subjective)<br>" 20

Text tripartite-a-case-name "A case name" "A takes a case named the " " (e.g. ergative, agentive)<br>" 20

Text tripartite-o-case-name "O case name" "O takes a case named the " " (e.g. absolutive, patientive)<br>" 20

Radio case-marking "Core case marking" "" ""
. split-s "Split-S" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>Split-S</b><br>"

Label "(The S argument of some intransitive verbs is marked by the same case as the agent of transitives, while for other verbs the S argument is marked by the same case as the patient.)<br>"

Text split-s-a-case-name "A case name" "A takes a case named the " " (e.g. ergative, agentive)<br>" 20

Text split-s-o-case-name "O case name" "O takes a case named the " " (e.g. absolutive, patientive)<br>" 20

Radio case-marking "Core case marking" "" ""
. fluid-s "Fluid-S" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>Fluid-S</b><br>"

Label "(The S argument of any intransitive verb can be marked either by the same case as the transitive agent or patient, depending on pragmatic factors, e.g. whether the S is perceived as being in control of the action.)<br>"

Text fluid-s-a-case-name "A case name" "A takes a case named the " " (e.g. ergative, agentive)<br>" 20

Text fluid-s-o-case-name "O case name" "O takes a case named the " " (e.g. absolutive, patientive)<br>" 20

Radio case-marking "Core case marking" "" ""
. split-n "Split N" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>Split conditioned on features of the noun phrase arguments</b><br>"

Label "(Some classes of noun phrases (e.g. pronouns) show a nominative-accusative pattern, while others (e.g. common nouns) show an ergative-absolutive pattern.  You will have an opportunity to define these classes on the Lexicon page.)<br>"

Text split-n-nom-case-name "Nominative case name" "S and A take a case named the " " (e.g. nominative, subjective)<br>" 20

Text split-n-acc-case-name "Accusative case name" "O takes a case named the " " (e.g. accusative, objective)<br>" 20

Text split-n-erg-case-name "Ergative case name" "A takes a case named the " " (e.g. ergative, relative, narrative)<br>" 20

Text split-n-abs-case-name "Absolutive case name" "S and O take a case named the " " (e.g. absolutive, nominative)<br>" 20

Radio case-marking "Core case marking" "" ""
. split-v "Split V" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>Split conditioned on features of the verb</b><br>"

Label "(Depending on some feature of the verb (e.g. tense or aspect), the core arguments are sometimes marked in a nominative-accusative pattern and other times in an ergative-absolutive pattern.  You will have an opportunity to define these features on the Lexicon page.)<br>"

Text split-v-nom-case-name "Nominative case name" "S and A take a case named the " " (e.g. nominative, subjective)<br>" 20

Text split-v-acc-case-name "Accusative case name" "O takes a case named the " " (e.g. accusative, objective)<br>" 20

Text split-v-erg-case-name "Ergative case name" "A takes a case named the " " (e.g. ergative, relative, narrative)<br>" 20

Text split-v-abs-case-name "Absolutive case name" "S and O take a case named the " " (e.g. absolutive, nominative)<br>" 20

Radio case-marking "Core case marking" "" ""
. focus "Focus" "<p style=\"margin-left:20px;text-indent:-20px\">" "<b>Focus-case</b><br>"

Label "(A number of Austronesian languages, including several Philippine languages, have a system where A and O are marked by cases.  An additional case, sometimes called the <span style=\"font-variant:small-caps\">focus</span>, is mandatory in every clause and has its grammatical role assigned by the morphology of the verb.  You will have an opportunity to define this morphology on the Lexicon page.)<br>"

Text focus-focus-case-name "Focus case name" "The focus case is named the " "<br>" 20

Text focus-a-case-name "A case name" "A takes a case named the " " (e.g. ergative, relative, narrative)<br>" 20

Text focus-o-case-name "O case name" "O takes a case named the " " (e.g. accusative, objective)<br>" 20

Label "<p><b>Additional Cases</b></p><p>If your language has any additional cases not covered above that occur in simple intransitive or transitive clauses (e.g. if you language has verbs whose O is marked by the dative), define those cases here:</p>"

BeginIter case{i} "a Case"

  Text name "Case {i} name" "Name: " "" 20

EndIter case


#Section person "Person"
#
#Label "<p>Under Construction</p>"


#Section number "Number"
#
#Label "<p>Under Construction</p>"


Section gender "Gender"

Label "<p>Insert prose here.  A single root type named <i>gender</i>, and the additional types you define below.</p>"

BeginIter gender{i} "a Gender"

  Text name "Gender {i} name" "Name: " "" 20

  Select supertype "Gender {i} supertype" ", which is a subtype of: " ""
  fillregex gender[0-9]+_name 1
  . gender "Gender" "gender"

EndIter gender


Section sentential-negation "Sentential Negation"

Label "<p>Please indicate which strategy or strategies your language uses for sentential negation (as distinct from constituent negation). (You may leave this section blank, in which case your grammar will not include any information about negation.)</p>"

Check infl-neg "Negation by inflection" "<p>" "Verbal inflection:<br>"

Radio neg-infl-type "Negative inflection type" "On: " ""
. aux "Auxiliaries only" "" "auxiliaries only "
. main "Main verbs only" "" "main verbs only "
. aux-main "Main or auxiliary verbs" "" "any finite verb (main or auxiliary)<br>"

Radio neg-aff "Negative affix type" "Affix type: " ""
. prefix "Prefix" "" "prefix "
. suffix "Suffix" "" "suffix<br>"

Text neg-aff-orth "Negative affix spelling" "Affix Spelling: " "</p>" 20

Check adv-neg "Adverbial negation" "<p>" "An adverb:<br>"

Radio neg-adv "Negative adverb" "" ""
. ind-adv "Independent" "" "...which is an independent modifier of "

Radio neg-mod "Negative adverb modifies" "" ""
. s "S" "" "S "
. vp "VP" "" "VP "
. v "V" "" "V "

Radio neg-order "Negative adverb order" "and appears " ""
. before "Before" "" "before "
. after "After" "" "after "
. either "Either" "" "on either side of the category it modifies.<br>"

Radio neg-adv "Negative adverb" "" ""
. sel-adv "Selected complement negative adverb" "" "...which is a selected complement of "

Radio neg-sel-adv "Negative adverb selects" "" ""
. main "Main verbs" "" "main verbs "
. aux "Auxiliary verbs" "" "auxiliaries "
. main-aux "Main or auxiliary verbs" "" "any finite verb<br>"

Text neg-adv-orth "Negative adverb spelling" "...and which is spelled: " "</p>" 20

Label "<p>Notes: The following options are not yet implemented: Negative inflection of non-finite verbs, special negative auxiliaries.</p>"

Radio multi-neg "Negative inflection and adverb" "<p>If you have selected both inflectional and adverbial negation, please indicate which of the following best describes your language:<br>" "</p>"
. comp "Complementary distribution" "" "Inflectional and adverbial negation are used in complementary distribution.<br>"
. both-opt "Both optional" "" "Inflectional and adverbial negation can appear independently or together.<br>"
. both-obl "Both obligatory" "" "Both inflection and the adverb are required to express sentential negation.<br>"
. adv-obl "Adverb obligatory" "" "The adverb is obligatory, but inflection may appear in addition.<br>"
. infl-obl "Inflection obligatory" "" "The inflection is obligatory, but the adverb may appear in addition."

Label "<p>Note: We assume that when negation is expressed via both inflection and an adverb at the same time, the adverb is treated as a selected complement.</p>"


Section coordination "Coordination"

Label "<p>Languages can have have multiple ways of marking coordination that can differ among the various parts of speech. The Matrix supports both lexical and morphological marking of coordination in several patterns. These patterns include:</p>"

Label "<p>Monosyndeton<br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;A B and C&quot; (one coordinand marked; also permits &quot;A and B and C&quot;)<br>Polysyndeton<br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;A and B and C&quot; (for N coordinands, N-1 marked)<br>N-Polysyndeton<br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;and A and B and C&quot; (all coordinands marked)<br>Asyndeton<br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;A B C&quot; (no marking; also called &quot;juxtaposition&quot;)</p>"

Check cs1 "Coordination strategy 1" "" "Coordination Strategy 1:<br>&nbsp;&nbsp;&nbsp;&nbsp;in which"

Check cs1_n "CS1 coordinates Ns" "" "nouns "
Check cs1_np "CS1 coordinates NPs" "" "NPs "
Check cs1_vp "CS1 coordinates VPs" "" "VPs "
Check cs1_s "CS1 coordinates Ss" "" "sentences<br>"

Radio cs1_pat "CS1 pattern" "&nbsp;&nbsp;&nbsp;&nbsp;are marked in a " ""
. mono "Monosyndeton" "" "monosyndeton "
. poly "Polysyndeton" "" "polysyndeton "
. omni "N-polysyndeton" "" "N-polysyndeton "
. a "Asyndeton" "" "asyndeton &nbsp; pattern<br>"

Radio cs1_mark "CS1 mark" "&nbsp;&nbsp;&nbsp;&nbsp;by a " ""
. word "Word" "" "word "
. affix "Affix" "" "affix "

Text cs1_orth "CS1 spelling" "spelled " "" 10

Radio cs1_order "CS1 order" "that comes " ""
. before "Before" "" "before "
. after "After" "" "after the coordinand<br><br>"

Check cs2 "Coordination strategy 2" "" "Coordination Strategy 2:<br>&nbsp;&nbsp;&nbsp;&nbsp;in which"

Check cs2_n "CS2 coordinates Ns" "" "nouns "
Check cs2_np "CS2 coordinates NPs" "" "NPs "
Check cs2_vp "CS2 coordinates VPs" "" "VPs "
Check cs2_s "CS2 coordinates Ss" "" "sentences<br>"

Radio cs2_pat "CS2 pattern" "&nbsp;&nbsp;&nbsp;&nbsp;are marked in a " ""
. mono "Monosyndeton" "" "monosyndeton "
. poly "Polysyndeton" "" "polysyndeton "
. omni "N-polysyndeton" "" "N-polysyndeton "
. a "Asyndeton" "" "asyndeton &nbsp; pattern<br>"

Radio cs2_mark "CS2 mark" "&nbsp;&nbsp;&nbsp;&nbsp;by a " ""
. word "Word" "" "word "
. affix "Affix" "" "affix "

Text cs2_orth "CS2 spelling" "spelled " "" 10

Radio cs2_order "CS2 order" "that comes " ""
. before "Before" "" "before "
. after "After" "" "after the coordinand "


Section matrix-yes-no "Matrix Yes/No Questions"

Label "<p>Please indicate which strategy your language uses to form matrix yes-no questions. Notes: You may leave this section blank, in which case your grammar will not include any information about questions.</p>"

Check q-part "Yes/No question particle" "" "A separate question particle: "

Radio q-part-order "Question particle order" "" ""
. before "Before" "" "sentence initial "
. after "After" "" "sentence final<br>"

Text q-part-orth "Question particle spelling" "&nbsp;&nbsp;&nbsp;&nbsp;Spelling of question particle: " "<br>" 40

Check q-infl "Inflection" "" "Verbal inflection:<br>"

Radio q-infl-type "Inflection type" "&nbsp;&nbsp;&nbsp;&nbsp;On: " ""
. aux "Auxiliaries only" "" "auxiliaries only "
. main "Main verbs only" "" "main verbs only "
. aux-main "Main or auxiliary verbs" "" "any finite verb (main or auxiliary)<br>"

Radio ques-aff "Affix type" "&nbsp;&nbsp;&nbsp;&nbsp;Affix type: " ""
. prefix "Prefix" "" "prefix "
. suffix "Suffix" "" "suffix<br>"

Text ques-aff-orth "Affix spelling" "&nbsp;&nbsp;&nbsp;&nbsp;Affix Spelling: " "<br>" 10

Check q-inv "Subject-verb inversion" "" "Subject-verb inversion: "

Radio q-inv-verb "Inverted verb in questions" "" ""
. main "Main" "" "main verbs only "
. aux "Auxiliary" "" "auxiliaries only "
. main-aux "Main and auxiliary" "" "any verb<br>"


Section lexicon "Lexicon"

Label "<p>On this page you will specify basic lexical types and lexical items for your language.  For each lexical item you must provide the spelling of the stem and a predicate (e.g. _cat_n_rel, _sleep_v_rel).</p>"

Label "<p>In addition to lexical types, you can define inflectional morphology for nouns, verbs, and determiners.  To do so, first define one or more inflectional <span style=\"font-variant:small-caps\">slots</span>, which determine the order morphemes appear, then define one or more <span style=\"font-variant:small-caps\">morphemes</span> that can appear in each slot, along with the <span style=\"font-variant:small-caps\">features</span> specified by each morpheme.  To determine the order of morphemes, you must define one or more <span style=\"font-variant:small-caps\">inputs</span> for each slot.  For morphemes that attach directly to stems, the input will be a lexical type; for morphemes that attach to already-inflected stems, the input will be another slot.</p>"

Label "<h3>Noun Types</h3>"

BeginIter noun{i} "a Noun Type" 1

  Text name "Noun {i} name" "<b>Noun type {i}</b>:<br>Name: " "<br>" 20

  Text orth "Noun {i} spelling" "Spelling: " "" 30

  Text pred "Noun {i} predicate" " Predicate: " "<br>" 30

  Radio det "Noun {i} determiner" "For this noun type, a determiner is " ""
  . obl "Obligatory" "" "obligatory "
  . opt "Optional" "" "optional "
  . imp "Impossible" "" "impossible "

EndIter noun

Label "<h3>Noun Inflection</h3>"

BeginIter noun-slot{i} "a Slot"

  Text name "Noun slot {i} name" "<b>Noun slot {i}</b>:<br>Name: " " " 20

  Check opt "Noun slot {i} optional" ", which is " " optional"

  Select order "Noun slot {i} order" " and appears " " the following inputs:<br>"
  . after "After" "after"
  . before "Before" "before"

  BeginIter input{j} "an Input" 1

    Select type "Noun slot {i} input {j} type" "Input: " ""
    fillregex (noun|verb|det)(-slot)?[0-9]+_name
    . noun "Any noun" "any noun"
    . verb "Any verb" "any verb"
    . iverb "Any intransitive verb" "any intransitive verb"
    . tverb "Any transitive verb" "any transitive verb"

  EndIter input

  BeginIter forces{j} "a Forced Slot"

    Select type "Noun slot {i} forces {j} type" "Forced slot: " ""
    fillregex (noun|verb|det)(-slot)?[0-9]+_name

  EndIter forces

  BeginIter req{j} "a Required Slot"

    Select type "Noun slot {i} req {j} type" "If <b>Noun slot {i}</b> appears, " " must also appear."
    fillregex (noun|verb|det)(-slot)?[0-9]+_name

  EndIter req

  BeginIter disreq{j} "a Forbidden Slot"

    Select type "Noun slot {i} req {j} type" "If <b>Noun slot {i}</b> appears, " " must <b>not</b> appear."
    fillregex (noun|verb|det)(-slot)?[0-9]+_name

  EndIter disreq

  Label "<p>Morpheme(s) that appear in this slot:</p>"

  BeginIter morph{j} "a Morpheme"

    Text name "Noun slot {i} morpheme {j} name" "Name: " ", " 20

    Text orth "Noun slot {i} morpheme {j} spelling" "spelling: " ", with the following features:<br>" 20

    BeginIter feat{k} "a Feature"

      Select name "Noun slot {i} morpheme {j} feature {k} name" "Name: " " "
      fillnames

      Select value "Noun slot {i} morpheme {j} feature {k} value" "Value: " ""
      fillvalues noun-slot{i}_morph{j}_feat{k}_name

    EndIter feat

  EndIter morph

EndIter noun-slot

Label "<h3>Verb Types</h3>"

BeginIter verb{i} "a Verb Type" 2

  Text name "Verb {i} name" "<b>Verb type {i}</b>:<br>Name: " "<br>" 20

  Text orth "Verb {i} spelling" "Spelling: " "" 30

  Text pred "Verb {i} predicate" " Predicate: " "<br>" 30

  Select valence "Verb {i} arguments" "Argument structure: " "<br>"
  fillverbpat

EndIter verb

Label "<h3>Auxiliary Verb Types</h3>"

BeginIter aux{i} "an Aux Type" 0

  Text orth "Aux {i} spelling" "<b>Auxiliary type {i}</b>:<br>Spelling: " "" 40

  Radio sem "Aux {i} semantics" "<br>This auxiliary verb contributes:<br>" ""
  . add-pred "Predicate" "" "An independent predicate (e.g. _can_v_rel): "

  Text pred "Aux{i} predicate" "Predicate: " "" 40

  Radio sem "Aux {i} semantics" "<br>" ""
  . no-pred "No predicate" "" "Tense/aspect information only"

  Radio comp "Aux {i} complement" "<br>This auxiliary verb takes as its complement a:<br>" ""
  . s "S" "" "saturated sentence<br>"
  . vp "VP" "" "VP, raising the subject<br>"
  . v "V" "" "V, raising all of its arguments (argument composition)"

  Radio compform "Aux {i} complement verb form" "<br>The form of the verb in this auxiliary's complement must be:<br>" ""
  . fin "finite" "" "finite<br>"
  . nf "nonfinite" "" "non-finite: "

  Text nonfincompform "Aux {i} nonfinite complement form" "Non-finite form (e.g. infinitive): " "<br>" 40

  Radio subj "Aux {i} subject" "If the auxiliary takes a VP or V complement, its subject is a: " ""
  . np "Noun phrase" "" "noun phrase "
  . adp "Adpositional phrase" "" "adpositional phrase "

EndIter aux

Label "<h3>Verb Inflection</h3>"

BeginIter verb-slot{i} "a Slot"

  Text name "Verb slot {i} name" "<b>Verb slot {i}</b>:<br>Name: " " " 20

  Check opt "Verb slot {i} optional" ", which is " " optional"

  Select order "Verb slot {i} order" " and appears " " the following inputs:<br>"
  . after "After" "after"
  . before "Before" "before"

  BeginIter input{j} "an Input" 1

    Select type "Verb slot {i} input {j} type" "Input: " ""
    fillregex (noun|verb|det)(-slot)?[0-9]+_name
    . noun "Any noun" "any noun"
    . verb "Any verb" "any verb"
    . iverb "Any intransitive verb" "any intransitive verb"
    . tverb "Any transitive verb" "any transitive verb"

  EndIter input

  BeginIter forces{j} "a Forced Slot"

    Select type "Verb slot {i} forces {j} type" "Forced slot: " ""
    fillregex (noun|verb|det)(-slot)?[0-9]+_name

  EndIter forces

  BeginIter req{j} "a Required Slot"

    Select type "Verb slot {i} req {j} type" "If <b>Verb slot {i}</b> appears, " " must also appear."

  EndIter req

  BeginIter disreq{j} "a Forbidden Slot"

    Select type "Verb slot {i} req {j} type" "If <b>Verb slot {i}</b> appears, " " must <b>not</b> appear."
    fillregex (noun|verb|det)(-slot)?[0-9]+_name

  EndIter disreq

  Label "<p>Morpheme(s) that appear in this slot:</p>"

  BeginIter morph{j} "a Morpheme"

    Text name "Verb slot {i} morpheme {j} name" "Name: " ", " 20

    Text orth "Verb slot {i} morpheme {j} spelling" "spelling: " ", with the following features:<br>" 20

    BeginIter feat{k} "a Feature"

      Select name "Verb slot {i} morpheme {j} feature {k} name" "Name: " " "
      fillnames

      Select value "Verb slot {i} morpheme {j} feature {k} value" "Value: " ""
      fillvalues verb-slot{i}_morph{j}_feat{k}_name

      Select head "Verb slot {i} morpheme {j} feature {k} head" "Specified on: " ""
      . verb "The verb" "the verb"
      . subj "The subject" "the subject NP"
      . obj "The object" "the object NP"

    EndIter feat

  EndIter morph

EndIter verb-slot

Label "<h3>Determiners</h3>"

Label "<p>If your nouns require determiners, define at least one here. You may use the second to handle a different determiner form (e.g., for languages where number, gender, or case are marked on determiners). Note that the grammar start won't actually include any constraints implementing agreement.</p>"

BeginIter det{i} "a Determiner"

  Text name "Determiner {i} name" "<b>Determiner {i}</b>:<br>Name: " "<br>" 20

  Text orth "Determiner {i} spelling" "Spelling: " "" 30

  Text pred "Determiner {i} predicate" " Predicate: " "<br>" 30

EndIter det

Label "<h3>Determiner Inflection</h3>"

BeginIter det-slot{i} "a Slot"

  Text name "Determiner slot {i} name" "<b>Determiner slot {i}</b>:<br>Name: " " " 20

  Check opt "Determiner slot {i} optional" ", which is " " optional"

  Select order "Determiner slot {i} order" " and appears " " the following inputs:<br>"
  . after "After" "after"
  . before "Before" "before"

  BeginIter input{j} "an Input" 1

    Select type "Determiner slot {i} input {j} type" "Input: " ""
    fillregex (noun|verb|det)(-slot)?[0-9]+_name
    . noun "Any noun" "any noun"
    . verb "Any verb" "any verb"
    . iverb "Any intransitive verb" "any intransitive verb"
    . tverb "Any transitive verb" "any transitive verb"

  EndIter input

  BeginIter forces{j} "a Forced Slot"

    Select type "Determiner slot {i} forces {j} type" "Forced slot: " ""
    fillregex (noun|verb|det)(-slot)?[0-9]+_name

  EndIter forces

  BeginIter req{j} "a Required Slot"

    Select type "Determiner slot {i} req {j} type" "If <b>Determiner slot {i}</b> appears, " " must also appear."
    fillregex (noun|verb|det)(-slot)?[0-9]+_name

  EndIter req

  BeginIter disreq{j} "a Forbidden Slot"

    Select type "Determiner slot {i} req {j} type" "If <b>Determiner slot {i}</b> appears, " " must <b>not</b> appear."
    fillregex (noun|verb|det)(-slot)?[0-9]+_name

  EndIter disreq

  Label "<p>Morpheme(s) that appear in this slot:</p>"

  BeginIter morph{j} "a Morpheme"

    Text name "Determiner slot {i} morpheme {j} name" "Name: " ", " 20

    Text orth "Determiner slot {i} morpheme {j} spelling" "spelling: " ", with the following features:<br>" 20

    BeginIter feat{k} "a Feature"

      Select name "Determiner slot {i} morpheme {j} feature {k} name" "Name: " " "
      fillnames

      Select value "Determiner slot {i} morpheme {j} feature {k} value" "Value: " ""
      fillvalues det-slot{i}_morph{j}_feat{k}_name

    EndIter feat

  EndIter morph

EndIter det-slot

Label "<h3>Case-marking Adpositions</h3>"

BeginIter adp{i} "an Adposition"

  Text orth "Adposition {i} spelling" "Spelling: " "" 20

  Select order "Noun slot {i} order" ", appearing " " an NP, on which it sets the following features:<br>"
  . after "After" "after"
  . before "Before" "before"

  BeginIter feat{j} "a Feature"

    Select name "Adposition {i} feature {j} name" "Name: " " "
    fillnames

    Select value "Adposition {i} feature {j} value" "Value: " ""
    fillvalues adp{i}_feat{j}_name

  EndIter feat

EndIter adp


Section test-sentences "Some Test Sentences"

Label "<p>By filling out the following two fields, you will give the LKB default strings to put into the parse dialog.  Please write two sentences using <b>only</b> the vocabulary defined above.  NB: This script can only handle lower ascii alphanumeric characters.</p>"

Text sentence1 "Sentence 1" "<p>Sentence 1: " "</p>" 100

Text sentence2 "Sentence 2" "<p>Sentence 2: " "</p>" 100
