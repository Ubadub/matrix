;; make rule for indefiniteness - where the COG status is set to ID

;; case and agreement
png :+ [ PER person,
	NUM number,
	GEN gender ].

;; feature to mark pronouns
individual :+ [ PRO bool ].


;; type to differentiate complementizers from question markers
comp :+ [ COMPTYPE compt ].

person := *top*.
first := person.
second := person.
third := person.

number := *top*.
sg := number.
non-sg := number.
dual := non-sg.
pl := non-sg.


gender := *top*.
masc := gender.
fem := gender.
neut := gender.

case := *top*.
nom+acc := case.
nom := nom+acc.
acc := nom+acc.
dat := case.


;; verb forms and tense

;;complet := tense.
;;pret := tense.
;;neg-comp := tense.
;;hab :=  tense.
past := tense.
present := tense.
future := tense.
;;subjunct := mood.

head :+ [ AUX bool,
    	FORM form ] .


; A-D forms for later implementation of verb grades
form := avm .

inf := form .
inflec := form.
fin := inflec .
imp := inflec.
Averb := fin.
Bverb := fin.
Cverb := fin.
Dverb := fin.


;;types for complementizers

compt := *top*.
qmarker := compt.
cpmarker := compt.

neg := head.

;; adposition (used only for indirect object - common nouns)

+np :+ [ CASE case ].

case-marker-p-lex := basic-one-arg & raise-sem-lex-item & 
   [ SYNSEM.LOCAL.CAT [ HEAD adp & [ MOD < > ],
                        VAL [ SPR < >, 
	                      SUBJ < >,
                              COMPS < #comps >,
                              SPEC < > ]],
     ARG-ST < #comps & [ LOCAL.CAT[ HEAD noun, VAL.SPR < > ]]> ].



;; discourse status for demonstratives

demonstrative_a_rel := predsort.
proximal+dem_a_rel := demonstrative_a_rel. ;; close to speaker.
distal+dem_a_rel := demonstrative_a_rel. ;; away from speaker.
remote+dem_a_rel := distal+dem_a_rel. ;;away from speaker and hearer
hearer+dem_a_rel := distal+dem_a_rel. ;;near hearer

;; phrase types

head-comp-phrase := basic-head-1st-comp-phrase & head-initial &
[ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <> ].

head-final-head-comp-phrase := head-final & basic-head-1st-comp-phrase & 
  [ HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD comp & 
				[ COMPTYPE qmarker ], 
				MC #mc ],
	NON-HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD.FORM inflec, 
					MC #mc ]].

head-opt-subj-phrase := decl-head-opt-subj-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD.FORM fin, MC +, 
				 VAL [ SUBJ < [ LOCAL.CAT.HEAD noun &
					 [ CASE nom ] ] >] ] ].

subj-head-phrase := decl-head-subj-phrase & head-final &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < > ] .

imperative-phrase :=  imp-head-opt-subj-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD verb & [ FORM imp] ] ].


negation-phrase := ternary-head-middle-phrase &
[ SYNSEM.LOCAL.CAT [ HEAD #head, VAL #val ],
  ARGS < L-neg-sentence-part, 
	[ SYNSEM.LOCAL [ CAT [ HEAD #head & verb & [FORM fin], 
				VAL #val & [ SUBJ < >,
					     COMPS < >,
					     SPR < >,
					     SPEC < >] ],
			CONT.HOOK [ LTOP #dltop, 
				    XARG #xarg ]]], 
	R-neg-sentence-part >,
  C-CONT [ RELS <! arg1-ev-relation & [LBL #ltop, 
				    PRED "_neg_r_rel",
				    ARG0 #index,
				     ARG1 #arg1 ]!>, 
	  HOOK [ LTOP #ltop, INDEX #index, XARG #xarg ], 
	  HCONS <! qeq & [HARG #arg1, LARG #dltop]!> ]].


; Rules for bulding NPs.  Note that the Matrix uses SPR for
; the specifier of nouns and SUBJ for the subject (specifier) of verbs.

head-spec-phrase := basic-head-spec-phrase & head-final.

; Bare NP phrase.  Consider modifying the PRED value of the quantifier relation
; introduced to match the semantic effect of bare NPs in your language.

bare-np-phrase := basic-bare-np-phrase &
  [C-CONT.RELS <! [ PRED "_exist_q_rel" ] !>] .

; Type for negative adverbs.

neg-adv-lex := basic-scopal-adverb-lex &
  [ SYNSEM.LOCAL.CAT [ VAL [ SPR < >,
                             COMPS < >,
                             SUBJ < > ],
                       HEAD.MOD < [ LOCAL.CAT.HEAD verb ] > ] ] .

neg-sentence-part-lex := norm-zero-arg &
[ INFLECTED + , 
  SYNSEM.LOCAL [ CAT [HEAD neg & [MOD < >],
		 VAL [SPR < >, 
		      SPEC < > , 
		      COMPS < >, 
		      SUBJ < >]], 
		CONT[ RELS <! !>, HCONS <! !>]]].

R-neg-sentence-part := neg-sentence-part-lex.

L-neg-sentence-part := neg-sentence-part-lex.

; This grammar includes head-modifier rules.  To keep
; out extraneous parses, constrain the value of MOD on
; various subtypes of head.  This may need to be loosened later.
; This constraint says that only adverbs, adjectives,
; and adpositions can be modifiers.

+nvcdmo :+ [ MOD < > ] .

;;; Coordination Strategy 1

np1-top-coord-rule := basic-np-top-coord-rule & apoly-top-coord-rule &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE #case, 
		   COORD-STRAT "1", 
		   CONT.HOOK.INDEX.PNG.NUM non-sg],
    LCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.CASE #case,
    RCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.CASE #case ] .

np1-bottom-coord-rule := conj-first-bottom-coord-rule & np-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ] .

;;; Coordination Strategy 1

vp1-top-coord-rule := basic-vp-top-coord-rule & apoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ] .

vp1-bottom-coord-rule := conj-first-bottom-coord-rule & vp-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ] .

; We treat question particles as complementizers.
; Here is the lexical type for complementizers.


complementizer-lex-item := raise-sem-lex-item & basic-one-arg & 
  [ SYNSEM.LOCAL.CAT [ HEAD comp &
                       [ MOD < > ],
                       VAL [ SPR < >,
                             SUBJ < >,
                             COMPS < #comp > ] ],
    ARG-ST < #comp &
             [ LOCAL.CAT [ HEAD verb,
                           VAL [ SUBJ < >,
                                 COMPS < > ] ] ] > ] .

ques-complementizer-lex-item := complementizer-lex-item &
[ SYNSEM.LOCAL [ CAT [ MC -, HEAD.COMPTYPE cpmarker ], 
		CONT.HOOK.INDEX.SF ques ] ].

prop-complementizer-lex-item :=  complementizer-lex-item &
[ SYNSEM.LOCAL[ CAT [ MC -, HEAD.COMPTYPE cpmarker ], 
		CONT.HOOK.INDEX.SF prop] ].

; Subtype for question particles. Constrains SF to ques.
qpart-lex-item := complementizer-lex-item &
  [ SYNSEM.LOCAL [ CAT [ MC +, HEAD.COMPTYPE qmarker, 
			VAL [ SUBJ < >,
			     SPEC < >, 
	 		     SPR < > ] ],
		CONT.HOOK.INDEX.SF ques ],
  ARG-ST < [LOCAL.CAT.HEAD.FORM inflec]> ] .

;;; Lexical types

noun :+ [ MOD < > ].
verb :+ [MOD < > ].
det :+ [ MOD < > ].
+nvd :+ [ MOD < > ].

;;; Nouns

noun-lex := basic-noun-lex & basic-one-arg & no-hcons-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < #spr & [ LOCAL.CAT.HEAD det ] >,
                           COMPS < >,
                           SUBJ < >,
                           SPEC < > ],
    ARG-ST < #spr >,
	INFLECTED - ] .

common-noun-lex := noun-lex &
[ SYNSEM.LOCAL[CAT.HEAD.CASE nom+acc, CONT.HOOK.INDEX.PNG [ PER third ]]] .

;;;; Pronouns

pronoun-lex := noun-lex &
[ SYNSEM [ LOCAL.CAT.VAL.SPR < [ OPT + ] > ,
	LKEYS.KEYREL.PRED "_pronoun_n_rel",
	LOCAL.CONT.HOOK.INDEX [ PRO +,
			COG-ST activ-or-more & [SPECI +] ] ]].

;;; Verbs

verb-lex := basic-verb-lex &
[ SYNSEM.LOCAL [ CAT.VAL [ SPR < >,
                           SPEC < >,
                           SUBJ < #subj > ],
                 CONT.HOOK [ XARG #xarg ]],
  ARG-ST < #subj & [ LOCAL [ CAT [ HEAD noun & [ CASE nom ],
				 VAL [ SPR < >,
                                       COMPS < > ]],
		CONT.HOOK.INDEX #xarg & [ PRO - ] ] ], ... >] .

intransitive-verb-lex := verb-lex & intransitive-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    ARG-ST < [ LOCAL.CAT [ HEAD noun ]	] > ] .

transitive-verb-lex := verb-lex & transitive-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < #comps >,
    ARG-ST < [ LOCAL.CAT.HEAD noun ], 
		#comps & [ LOCAL.CAT [ VAL [ SPR < >, COMPS < > ],
                 		       HEAD noun & [ CASE acc ] ] ] > ] .

ditransitive-verb-lex := verb-lex & ditransitive-lex-item &
[ SYNSEM.LOCAL.CAT.VAL.COMPS < #comps1, #comps2 >,
	ARG-ST < [ LOCAL.CAT.HEAD noun ], 
		#comps1 & [ OPT - ], 
		#comps2 & [ OPT - ]> ].

dat-ditrans-verb-lex := ditransitive-verb-lex &
[ ARG-ST <[ LOCAL.CAT.HEAD noun ] , 
	[ LOCAL.CAT.HEAD +np & [ CASE dat ]],
	[ LOCAL.CAT.HEAD noun & [ CASE acc ]]>].


clausal-comp-trverb-lex := verb-lex & clausal-second-arg-trans-lex-item &
[ SYNSEM.LOCAL [ CAT.VAL [ COMPS < #comps & [ LOCAL.CAT [ MC -,
					     VAL [ SUBJ < > , COMPS < > ],
				             HEAD +vc ]]> ],
			 CONT.HOOK.INDEX.SF prop-or-ques ],
  ARG-ST < [LOCAL.CAT.HEAD noun], #comps>].

clausal-comp-dtrverb-lex := verb-lex & clausal-third-arg-ditrans-lex-item &
[ SYNSEM.LOCAL [ CAT.VAL [ COMPS <#comps1 & [ LOCAL.CAT.HEAD noun & [ CASE dat ]],
				 #comps2 & [ LOCAL.CAT [ MC -,
					      VAL [ SUBJ < >, COMPS < > ],
					      HEAD +vc ]]> ],
		 CONT.HOOK.INDEX.SF prop-or-ques ],
  ARG-ST < [LOCAL.CAT.HEAD noun],#comps1, #comps2> ].

ques-comp-dtrverb-lex := clausal-comp-dtrverb-lex &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques ].

prop-comp-dtrverb-lex := clausal-comp-dtrverb-lex &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop ].

ques-comp-trverb-lex := clausal-comp-trverb-lex &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques ].

prop-comp-trverb-lex := clausal-comp-trverb-lex &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop ].

;;auxiliaries
aux-verb-lex := verb-lex & trans-first-arg-raising-lex-item-1 &
[ SYNSEM.LOCAL [ CAT.VAL [ SUBJ < [ LOCAL.CAT.HEAD noun ] >,
			 COMPS < #comps & [ LOCAL.CAT.HEAD verb &
					 [ FORM inf ]]>]],
	ARG-ST < [ LOCAL.CAT.HEAD noun ], #comps>].


;;adjectives 

adjective-lex := basic-int-mod-adj-lex & 
[SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [LOCAL [CAT [HEAD noun,
			VAL.SPR cons ]]] >,
VAL [SPR < >,
	SUBJ < >,
	COMPS < > ,
	SPEC < > ]]]]].

f-adjective-lex := adjective-lex &
[ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.PNG [ GEN fem]]>].

m-adjective-lex := adjective-lex &
[ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.PNG [ GEN masc]]>].

p-adjective-lex := adjective-lex &
[ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.PNG [ NUM non-sg]]>].

;;adverbs

adverb-lex := basic-adverb-lex & intersective-mod-lex & 
[ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT[ HEAD verb, VAL [ COMPS < >, SUBJ < >] ]]>,
	VAL [ SPR < >,
		SUBJ < > ,
		COMPS < >,
		SPEC  < >]]]]].

;;; Determiners
;;; SPEC is non-empty, and already specified by basic-determiner-lex.

determiner-lex := basic-determiner-lex & basic-zero-arg &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < >,
                           COMPS < >,
                           SUBJ < > ] ] .

demonstrative-determiner-lex := norm-hook-lex-item & basic-zero-arg &
[ SYNSEM [ LOCAL [CAT [ HEAD det,
	VAL[ SPEC.FIRST.LOCAL.CONT.HOOK [ INDEX #ind & [COG-ST activ+fam],
					LTOP #larg & #lbl],
	SPR < >,
	SUBJ < >,
	COMPS < >]],
CONT [ HCONS < ! qeq & 
	[ HARG #harg,
	LARG #larg ] ! >, RELS <![ PRED "exist_q_rel"], #lkey & arg12-relation & [LBL #lbl] ! >] ] ,
LKEYS [ KEYREL quant-relation &
	[ ARG0 #ind,
	RSTR #harg ], ALTKEYREL #lkey]]].

f-demonstrative-lex := demonstrative-determiner-lex &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ GEN fem]].

m-demonstrative-lex := demonstrative-determiner-lex &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ GEN masc]].


;;;; Lexical rules

;; rules for definiteness suffix (nouns)

f-definiteness-lex-rule := infl-ltow-rule &
	[ SYNSEM.LOCAL.CONT.HOOk.INDEX[ PNG [ GEN fem, NUM sg],
					COG-ST uniq+fam+act ],
	DTR.SYNSEM.LOCAL.CAT.HEAD noun ].
m-definiteness-lex-rule :=  infl-ltow-rule &
	[ SYNSEM.LOCAL.CONT.HOOk.INDEX[ PNG [ GEN masc, NUM sg],
					COG-ST uniq+fam+act ],
	DTR.SYNSEM.LOCAL.CAT.HEAD noun ].
p-definiteness-lex-rule :=  infl-ltow-rule &
	[ SYNSEM.LOCAL.CONT.HOOK.INDEX[ PNG [ NUM non-sg],
					COG-ST uniq+fam+act ],
	DTR.SYNSEM.LOCAL.CAT.HEAD noun ].

;; rules for indefiniteness (nouns without suffix)
n-indef-lex-rule := const-ltow-rule &
	[ SYNSEM.LOCAL.CONT.HOOK.INDEX [ PNG [PER first, NUM sg ]],
	DTR.SYNSEM.LOCAL.CAT.HEAD noun ].

f-indef-lex-rule := const-ltow-rule &
	[ SYNSEM.LOCAL.CONT.HOOK.INDEX[ PNG [ GEN fem, NUM sg] ],
	DTR.SYNSEM.LOCAL.CAT.HEAD noun ].

m-indef-lex-rule :=  const-ltow-rule &
	[ SYNSEM.LOCAL.CONT.HOOk.INDEX[ PNG [ GEN masc, NUM sg] ],
	DTR.SYNSEM.LOCAL.CAT.HEAD noun ].

p-indef-lex-rule :=  const-ltow-rule &
	[ SYNSEM.LOCAL.CONT.HOOK.INDEX[ PNG [ NUM non-sg]],
	DTR.SYNSEM.LOCAL.CAT.HEAD noun].



;; rules for adding the linker (adjectives)

no-linker-adj-lex-rule := const-ltow-rule &
[ SYNSEM.LOCAL [ CAT.POSTHEAD + ],
DTR.SYNSEM.LOCAL.CAT [ HEAD adj ] ].

adj-lex-rule := infl-ltow-rule &
[ SYNSEM.LOCAL[ CAT.POSTHEAD -],
DTR.SYNSEM.LOCAL.CAT.HEAD adj ].

f-adj-lex-rule := adj-lex-rule &
[ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.PNG [ GEN fem, NUM sg]]> ].


m-adj-lex-rule := adj-lex-rule &
[ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.PNG [ GEN masc, NUM sg ]]> ].


p-adj-lex-rule := adj-lex-rule &
[ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.PNG [ NUM non-sg ]]> ].




;; infinitive (zero PAC) rule

null-PAC-verb-lex-rule := const-ltow-rule &
[ SYNSEM.LOCAL.CAT.HEAD.FORM inf,
DTR.SYNSEM.LOCAL.CAT [HEAD verb ]].

;; person rules - supertypes for verb inflection

1sg-verb-lex-rule := infl-ltow-rule &
[ SYNSEM.LOCAL [CAT[ HEAD.FORM fin,
		     VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER first,
							      NUM sg ] ]>]],
	DTR.SYNSEM.LOCAL.CAT.HEAD verb ].

2f-verb-lex-rule := infl-ltow-rule &
[ SYNSEM.LOCAL [CAT[ HEAD.FORM fin,
		     VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER second,
						NUM sg, GEN fem ] ]>]],
	DTR.SYNSEM.LOCAL.CAT.HEAD verb ].

2m-verb-lex-rule := infl-ltow-rule &
[ SYNSEM.LOCAL [CAT[ HEAD.FORM fin, 
		     VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER second,
						NUM sg, GEN masc ] ]>]],
	DTR.SYNSEM.LOCAL.CAT.HEAD verb ].

3f-verb-lex-rule := infl-ltow-rule &
[ SYNSEM.LOCAL [CAT[ HEAD.FORM fin, 
		     VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER third,
						NUM sg, GEN fem ] ]>]],
	DTR.SYNSEM.LOCAL.CAT.HEAD verb ].

3m-verb-lex-rule := infl-ltow-rule &
[ SYNSEM.LOCAL [CAT[ HEAD.FORM fin, 
		     VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER third,
						NUM sg, GEN masc ] ]>]],
	DTR.SYNSEM.LOCAL.CAT.HEAD verb ].

1p-verb-lex-rule := infl-ltow-rule &
[ SYNSEM.LOCAL [CAT[ HEAD.FORM fin,
		     VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER first,
						NUM non-sg ] ]>]],
	DTR.SYNSEM.LOCAL.CAT.HEAD verb ].

2p-verb-lex-rule := infl-ltow-rule &
[ SYNSEM.LOCAL [CAT[ HEAD.FORM fin, 
		     VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER second,
						NUM non-sg ] ]>]],
	DTR.SYNSEM.LOCAL.CAT.HEAD verb ].

3p-verb-lex-rule := infl-ltow-rule &
[ SYNSEM.LOCAL [CAT[ HEAD.FORM fin, 
		     VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER third,
						NUM non-sg ] ]>]],
	DTR.SYNSEM.LOCAL.CAT.HEAD verb ].


;; rules for completive verbs

complet-verb-lex-rule := infl-ltow-rule &
[SYNSEM.LOCAL.CONT.HOOK.INDEX.E [TENSE past]].

1sg-complet-verb-lex-rule := complet-verb-lex-rule & 1sg-verb-lex-rule.

2m-complet-verb-lex-rule := complet-verb-lex-rule & 2m-verb-lex-rule.

2f-complet-verb-lex-rule := complet-verb-lex-rule & 2f-verb-lex-rule.

3m-complet-verb-lex-rule := complet-verb-lex-rule & 3m-verb-lex-rule. 

3f-complet-verb-lex-rule := complet-verb-lex-rule & 3f-verb-lex-rule.

1p-complet-verb-lex-rule := complet-verb-lex-rule & 1p-verb-lex-rule.

2p-complet-verb-lex-rule := complet-verb-lex-rule & 2p-verb-lex-rule.

3p-complet-verb-lex-rule := complet-verb-lex-rule & 3p-verb-lex-rule.

;; continuous

contin-verb-lex-rule := infl-ltow-rule &
[SYNSEM.LOCAL.CONT.HOOK.INDEX.E [TENSE present]].

1sg-contin-verb-lex-rule := contin-verb-lex-rule & 1sg-verb-lex-rule.

2m-contin-verb-lex-rule := contin-verb-lex-rule & 2m-verb-lex-rule.

2f-contin-verb-lex-rule := contin-verb-lex-rule & 2f-verb-lex-rule.

3m-contin-verb-lex-rule := contin-verb-lex-rule & 3m-verb-lex-rule.

3f-contin-verb-lex-rule := contin-verb-lex-rule & 3f-verb-lex-rule.

1p-contin-verb-lex-rule := contin-verb-lex-rule & 1p-verb-lex-rule.

2p-contin-verb-lex-rule := contin-verb-lex-rule & 2p-verb-lex-rule.

3p-contin-verb-lex-rule := contin-verb-lex-rule & 3p-verb-lex-rule.

;;future tense

future-verb-lex-rule := infl-ltow-rule &
[SYNSEM.LOCAL.CONT.HOOK.INDEX.E [TENSE future] ].

1sg-future-verb-lex-rule := future-verb-lex-rule & 1sg-verb-lex-rule.

2m-future-verb-lex-rule :=  future-verb-lex-rule & 2m-verb-lex-rule.

2f-future-verb-lex-rule :=  future-verb-lex-rule & 2f-verb-lex-rule.

3m-future-verb-lex-rule :=  future-verb-lex-rule & 3m-verb-lex-rule.

3f-future-verb-lex-rule :=  future-verb-lex-rule & 3f-verb-lex-rule.

1p-future-verb-lex-rule := future-verb-lex-rule  & 1p-verb-lex-rule.

2p-future-verb-lex-rule :=  future-verb-lex-rule & 2p-verb-lex-rule.

3p-future-verb-lex-rule :=  future-verb-lex-rule & 3p-verb-lex-rule.


;; rules for subjunctive


;;rules for preterite
