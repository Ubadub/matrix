;;; -*- Mode: TDL; Package: LKB -*-
;;;
;;; Basic lexical types, just enough to test word
;;; order modules for now.  Will need to build this
;;; out as a set of alternative modules.

; For my own sanity in testing the free word order
; module, implement a tiny bit of case.  Case values
; declared directly on noun lexical entries, for now.

case := *top*.
nom := case.
acc := case.
dat := case.

noun :+ [ CASE case ].

noun-lex := basic-noun-lex & basic-one-arg &
  [ SYNSEM.LOCAL [ CAT.VAL [ SPR < #spr >,
			     COMPS < >,
			     SUBJ < >,
			     SPEC < > ]],
    ARG-ST < #spr > ].

transitive-verb-lex := basic-verb-lex & transitive-lex-item &
  [ SYNSEM.LOCAL [ CAT.VAL [ SPR < >,
			     COMPS < #comps >,
			     SUBJ < #subj >,
			     SPEC < > ]],
    ARG-ST < #subj &
	     [ LOCAL.CAT [ HEAD.CASE nom,
			   VAL.SPR < > ]], 
	     #comps &
	     [ LOCAL.CAT [ HEAD.CASE acc,
			   VAL.SPR < > ]] > ].

intransitive-verb-lex := basic-verb-lex & intransitive-lex-item &
  [ SYNSEM.LOCAL [ CAT.VAL [ SPR < >,
			     COMPS < >,
			     SUBJ < #subj >,
			     SPEC < > ]],
    ARG-ST < #subj &
	     [ LOCAL.CAT [ HEAD.CASE nom,
			   VAL.SPR < > ]] > ].

ditransitive-verb-lex := basic-verb-lex & ditransitive-lex-item &
  [ SYNSEM.LOCAL [ CAT.VAL [ SPR < >,
			     COMPS < #comps1, #comps2 >,
			     SUBJ < #subj >,
			     SPEC < > ]],
    ARG-ST < #subj &
	     [ LOCAL.CAT [ HEAD.CASE nom,
			   VAL.SPR < > ]], 
	     #comps1 &
	     [ LOCAL.CAT [ HEAD.CASE acc,
			   VAL.SPR < > ]],
	     #comps2 &
	     [ LOCAL.CAT [ HEAD.CASE dat,
			   VAL.SPR < > ]] > ].
